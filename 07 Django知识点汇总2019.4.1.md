#07 Django知识点汇总2019.4.1



53、django中如何实现单元测试？



55、django中如何根据数据库表生成model中的类？



57、简述MVC和MTV



## 一 web相关

1、简述HTTP协议及常见请求头

```
HTTP协议：

常见请求头：
- user-agent
- host
- referer
- cookie 
- content-type

常见响应头：
- cookie -> set-cookie
- location
```

2、列举常见的请求方法

4、Http和Https的区别？

5、简述websocket协议及实现原理

6、django中如何实现websocket？

7、Python web开发中，跨域问题的解决思路是？

8、请简述http缓存机制

9、下面关于http协议中的get和post方式的区别，哪些是错误的？

- A. 它们都可以被收藏，以及缓存
- B. get请求参数放在url中
- C. get只用于查询请求，不能用于数据请求
- D. get不能处理敏感数据的请求

10、什么是`cors`

```
浏览器将CORS请求分成两类：简单请求 和 复杂请求

简单请求：(要同时满足以下两大条件)
1)请求的方法是以下三种方法之一：
HEAD
GET
POST
2)HTTP的头信息不超过以下几种字段：
Accept
Accept-Language
Content-Language
Last-Event-ID
Content-Type :只限于三个值application/x-www-form-urlencoded,multipart/form-data,text/plain

复杂请求就是不同时满足上述两个条件的非简单请求
```

11、django，flask，tornado框架的比较

```
- Django
对于django，大而全的框架它的内部组件比较多，内部提供：ORM、Admin、中间件、Form、ModelForm、Session、
缓存、信号、CSRF；功能也都挺完善的

- Flask，
微型框架，内部组件就比较少了，但是有很多第三方组件来扩展它，
比如说有那个wtform（与django的modelform类似，表单验证）、flask-sqlalchemy(操作数据库的)、flask-session、flask-migrate、flask-script、blinker可扩展强，第三方组件丰富。所以对他本身来说有那种短小精悍的感觉


django和flask的共同点就是，他们2个框架都没有写socket，所以他们都是利用第三方模块wsgi。
但是内部使用的wsgi也是有些不同的：django本身运行起来使用wsgiref，而flask使用werkzeug wsgi

还有一个区别就是他们的请求管理不太一样：django是通过将请求封装成request对象，再通过参数传递，而flask是通过上下文管理机制


- Tornado
是一个轻量级的Web框架，异步非阻塞+内置WebSocket功能。
'目标'：通过一个线程处理N个并发请求(处理IO)。
内部组件
    #内部自己实现socket
    #路由系统
    #视图
模板
　　#cookie
    #csrf
```



12、什么是wsgi



## 二 django相关

### 1、简述下django内建的缓存机制

```

```



2、列举一下django的内置组件

```
form 组件
- 对用户请求的数据进行校验
- 生成HTML标签
PS：
- form对象是一个可迭代对象。
- 问题：choice的数据如果从数据库获取可能会造成数据无法实时更新
        - 重写构造方法，在构造方法中重新去数据库获取值。
        - ModelChoiceField字段
            from django.forms import Form
            from django.forms import fields
            from django.forms.models import ModelChoiceField
            class UserForm(Form):
                name = fields.CharField(label='用户名',max_length=32)
                email = fields.EmailField(label='邮箱')
                ut_id = ModelChoiceField(queryset=models.UserType.objects.all())    
            
            依赖：
                class UserType(models.Model):
                    title = models.CharField(max_length=32)

                    def __str__(self):
                        return self.title

信号、
django的信号其实就是django内部为开发者预留的一些自定制功能的钩子。
只要在某个信号中注册了函数，那么django内部执行的过程中就会自动触发注册在信号中的函数。
如： 
pre_init # django的modal执行其构造方法前，自动触发
post_init # django的modal执行其构造方法后，自动触发
pre_save # django的modal对象保存前，自动触发
post_save # django的modal对象保存后，自动触发
场景:
在数据库某些表中添加数据时，可以进行日志记录。

CSRF、
目标：防止用户直接向服务端发起POST请求。
对所有的post请求做验证/ 将jango生成的一串字符串发送给我们，一种是从请求体发过来，一种是放在隐藏的标签里面用的是process_view　
方案：先发送GET请求时，将token保存到：cookie、Form表单中（隐藏的input标签），
以后再发送请求时只要携带过来即可。

ContentType 
contenttype是django的一个组件（app），
为我们找到django程序中所有app中的所有表并添加到记录中。
 可以使用他再加上表中的两个字段实现：一张表和N张表创建FK关系。 - 字段：表名称 - 字段：数据行ID 
应用：路飞表结构优惠券和专题课和学位课关联。

中间件
对所有的请求进行批量处理，在视图函数执行前后进行自定义操作。
应用：用户登录校验
问题：为甚么不使用装饰器？
如果不使用中间件，就需要给每个视图函数添加装饰器，太繁琐

session
cookie与session区别
（a）cookie是保存在浏览器端的键值对，而session是保存的服务器端的键值对，但是依赖cookie。
（也可以不依赖cookie，可以放在url，或请求头但是cookie比较方便）
（b）以登录为例，cookie为通过登录成功后，设置明文的键值对，并将键值对发送客户端存，明文信息可能存在泄漏，不安全；
　　session则是生成随机字符串，发给用户，并写到浏览器的cookie中，同时服务器自己也会保存一份。
（c）在登录验证时，cookie：根据浏览器发送请求时附带的cookie的键值对进行判断，如果存在，则验证通过；
　　session：在请求用户的cookie中获取随机字符串，根据随机字符串在session中获取其对应的值进行验证

cors跨域（场景：前后端分离时，本地测试开发时使用）
如果网站之间存在跨域，域名不同，端口不同会导致出现跨域，但凡出现跨域，浏览器就会出现同源策略的限制
解决：在我们的服务端给我们响应数据，加上响应头---> 在中间件加的

缓存
常用的数据放在缓存里面，就不用走视图函数，请求进来通过所有的process_request,会到缓存里面查数据，有就直接拿，
　　　　　　　　没有就走视图函数
　　　　　　关键点：1：执行完所有的process_request才去缓存取数据
　　　　　　　　　　2：执行完所有的process_response才将数据放到缓存

关于缓存问题:
1:为什么放在最后一个process_request才去缓存
因为需要验证完用户的请求，才能返回数据
2:什么时候将数据放到缓存中
第一次走中间件，缓存没有数据，会走视图函数，取数据库里面取数据，
当走完process_response,才将数据放到缓存里，因为，走process_response的时候可能给我们的响应加处理

为什么使用缓存
将常用且不太频繁修改的数据放入缓存。
以后用户再来访问，先去缓存查看是否存在，如果有就返回
否则，去数据库中获取并返回给用户（再加入到缓存，以便下次访问）
```





50、django路由系统中name的作用？



31、F和Q的作用?

**F:主要用来获取原数据进行计算。**
1. Django 支持 F()对象之间 以及 F()对象和常数之间 的加减乘除和取模的操作。
2. 修改操作也可以使用F函数,比如将每件商品的价格都在原价格的基础上增加10
```Python
from django.db.models import F
from app01.models import Goods
 
Goods.objects.update(price=F("price")+10)  # 对于goods表中每件商品的价格都在原价格的基础上增加10元
```
3. F查询专门对对象中某列值的操作，不可使用__双下划线！

**Q:用来进行复杂查询**
```
Q查询可以组合使用 “&”, “|” 操作符，当一个操作符是用于两个Q的对象,它产生一个新的Q对象，
Q对象可以用 “~” 操作符放在前面表示否定，也可允许否定与不否定形式的组合。
Q对象可以与关键字参数查询一起使用，不过一定要把Q对象放在关键字参数查询的前面。

  Q(条件1) | Q(条件2) 或
  Q(条件1) & Q(条件2) 且
  Q(条件1) & ~Q(条件2) 非
```
33

36、列举django orm中三种能写sql语句的方法。

- 原生SQL ---> `connection`
```python
from django.db import connection, connections
cursor = connection.cursor()  
# cursor = connections['default'].cursor()

cursor.execute("""SELECT * from auth_user where id = %s""", [1])
row = cursor.fetchone() # fetchall()/fetchmany(..)
```
- 靠近原生SQL --> `extra`
```python
def extra(self, select=None, where=None, params=None, tables=None, order_by=None, 
select_params=None)
        # 构造额外的查询条件或者映射，如：子查询
        Entry.objects.extra(select={'new_id': "select col from sometable where othercol > %s"},
 select_params=(1,))
        Entry.objects.extra(where=['headline=%s'], params=['Lennon'])
        Entry.objects.extra(where=["foo='a' OR bar = 'a'", "baz = 'a'"])
        Entry.objects.extra(select={'new_id': "select id from tb where id > %s"}, s
elect_params=(1,), order_by=['-nid'])
```
- 靠近原生SQL --> `raw`
```python
def raw(self, raw_query, params=None, translations=None, using=None):
    # 执行原生SQL
    models.UserInfo.objects.raw('select * from userinfo')
    # 如果SQL是其他表时，必须将名字设置为当前UserInfo对象的主键列名
    models.UserInfo.objects.raw('select id as nid,name as title  from 其他表')
    # 为原生SQL设置参数
    models.UserInfo.objects.raw('select id as nid from userinfo where nid>%s', params=[12,])
    # 将获取的到列名转换为指定列名
    name_map = {'first': 'first_name', 'last': 'last_name', 'bd': 'birth_date', 'pk': 'id'}
    Person.objects.raw('SELECT * FROM some_other_table', translations=name_map)
    # 指定数据库
    models.UserInfo.objects.raw('select * from userinfo', using="default")
```
36、filter和exclude的区别？

37、django orm 中如何设置读写分离？

方式一：手动使用`queryset`的`using`方法
```python
from django.shortcuts import render,HttpResponse
from app01 import models

def index(request):
    models.UserType.objects.using('db1').create(title='普通用户')
　　# 手动指定去某个数据库取数据
    result = models.UserType.objects.all().using('db1')
    print(result)

    return HttpResponse('...')
```
方式二：写配置文件
```python
class Router1:
　　 # 指定到某个数据库取数据
    def db_for_read(self, model, **hints):
        """
        Attempts to read auth models go to auth_db.
        """
        if model._meta.model_name == 'usertype':
            return 'db1'
        else:
            return 'default'
　　 
    # 指定到某个数据库存数据
    def db_for_write(self, model, **hints):
        """
        Attempts to write auth models go to auth_db.
        """
        return 'default'
再写到配置
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    },
    'db1': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
DATABASE_ROUTERS = ['db_router.Router1',]
```
37、values和values_list的区别？

38、如何使用django orm批量创建数据？

39、django的Form和ModeForm的作用？

40、django的Form组件中，如果字段中包含choices参数，请使用两种方式实现数据源实时更新。

41、django的Model中的ForeignKey字段中的on_delete参数有什么作用？

56、使用orm和原生sql的优缺点？
```shell
# 原生SQL:
优点: 执行速度快
缺点:编写复杂,开发效率不高

# ORM:
优点:
1.让用户不再写SQL语句,提高开发效率
2.可以很方便的引入数据缓存之类的附加功能
缺点:
1.在处理多表联查,where条件复杂查询时,ORM语法会变得复杂
2.没有原生SQL速度快
```

47、django中如何实现orm表中添加数据时创建一条日志记录。



45、django缓存如何设置？

46、django的缓存能使用redis吗？如果可以的话，如何配置？



42、django中csrf的实现机制？

43、django如何实现websocket？

44、基于django使用ajax发送post请求时，都可以使用哪种方法携带csrf token？

48、django的模板中filter和simple_tag和inclusion_tag的区别？

### 49、django-debug-toolbar的作用？

```
django-debug-toolbar 是一组可配置的面板，可显示有关当前请求/响应的各种调试信息，并在单击时显示有关面板内容的更多详细信息。

详细内容：
https://www.cnblogs.com/maple-shaw/articles/7808910.html
```



51、解释orm中 db first 和 code first的含义？

55、django的contenttype组件的作用？



## django rest framework框架相关

59、谈谈你对restfull 规范的认识？

60、接口的幂等性是什么意思？

61、什么是RPC？

63、为什么要使用django rest framework框架？

64、django rest framework框架中都有那些组件？

65、django rest framework框架中的视图都可以继承哪些类？

66、简述 django rest framework框架的认证流程。

67、django rest framework如何实现的用户访问频率控制？